<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>KeyGenesis - Bulk Password Generator</title>
<link rel="icon" type="image/png" href="favicon.png">
<style>
  body{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;max-width:1100px;margin:20px auto;padding:18px;line-height:1.45}
  h1{font-size:20px;margin:0 0 6px}
  .grid{display:flex;gap:12px;flex-wrap:wrap}
  label{display:block;font-weight:600;margin-top:10px}
  input[type=number],select,textarea,input[type=text]{padding:8px;border:1px solid #ddd;border-radius:6px}
  textarea{width:100%;height:160px;margin-top:8px;font-family:monospace}
  button{padding:8px 12px;border-radius:8px;border:1px solid #ccc;background:#0b74de;color:#fff;cursor:pointer}
  .muted{color:#666;font-size:13px}
  table{width:100%;border-collapse:collapse;margin-top:12px}
  th,td{padding:6px;border:1px solid #eee;font-family:monospace}
  .small-btn{padding:6px 8px;font-size:13px;border-radius:6px;background:#444;color:#fff;border:none;cursor:pointer}
  .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-top:10px}
  .flex{display:flex;gap:8px;align-items:center}
  .note{font-size:13px;color:#444;margin-top:6px}
  .meta{font-size:13px;color:#222;margin-top:6px}
</style>
</head>
<body>
  <div style="text-align:center; margin-bottom: 40px; position: relative;">
    <h1 style="font-size: 2.5em; margin: 0; display: inline-block; position: relative; line-height: 0.95;">
      <span>KeyGenesis</span>
      <img src="logo.jpg" alt="Logo" style="height: 3em; width: auto; position: absolute; right: 100%; margin-right: 12px; top: 50%; transform: translateY(-50%);">
    </h1>
    <h2 style="font-size: 1.3em; margin: 4px 0 4px 0; color: #222;">Bulk Password Generator</h2>
    <h3 style="font-size: 0.95em; margin: 0; color: #666;">A Bcreate Systems Project - Vibe Coded and Designed by ALOK</h3>
  </div>

  <!-- Wordlist folder loader -->
  <label>Load wordlist from folder (select a folder containing .txt files)</label>
  <input id="folderPicker" type="file" webkitdirectory directory multiple />
  <div class="meta" id="folderNote">No folder loaded. Using built-in pool or textarea input.</div>
  <div style="margin-top:8px">
    <button id="useLoadedPool" disabled>Use loaded pool for generation</button>
    <button id="clearCachedPool">Clear cached pool</button>
  </div>

  <label style="margin-top:12px">Optional word list (one word per line) — leave blank to use loaded folder or built-in</label>
  <textarea id="wordlist" placeholder="amber\nriver\norbit"></textarea>

  <div class="grid">
    <div>
      <label>Words per password</label>
      <input id="wordsPer" type="number" min="1" value="3"/>
    </div>

    <div>
      <label>Characters per word</label>
      <input id="charsPerWord" type="number" min="0" value="0"/>
    </div>

    <div>
      <label>Digits per password</label>
      <input id="digitsPer" type="number" min="0" value="2"/>
    </div>

    <div>
      <label>Passwords to generate</label>
      <input id="count" type="number" min="1" value="50"/>
    </div>

    <div>
      <label>Separator</label>
      <select id="sep">
        <option value="-">dash (-)</option>
        <option value="_">underscore (_)</option>
        <option value="">none</option>
        <option value=" ">space ( )</option>
      </select>
    </div>

    <div style="min-width:220px">
      <label style="display:flex;align-items:center;gap:8px"><input id="capitalizeFirst" type="checkbox"/> Capitalize first word</label>
      <label style="display:flex;align-items:center;gap:8px"><input id="uniqueWords" type="checkbox"/> Unique words per password (if pool large)</label>
    </div>

    <div>
      <label>Digit placement</label>
      <select id="digitPlacement">
        <option value="end">Append at end</option>
        <option value="start">Prepend at start</option>
        <option value="after_each">Insert after each word</option>
        <option value="per_word_random">Per-word random insert</option>
        <option value="inside_each_word">Ensure at least one digit inside each word</option>
      </select>
      <div class="note">All processing is local. For extremely large pools (>50k), allow a few seconds to import & index.</div>
    </div>
  </div>

  <div class="controls">
    <button id="generate">Generate & Show</button>
    <button id="copyAll" disabled>Copy All (plain lines)</button>
    <button id="copyFormatted" disabled>Copy (Formatted)</button>

    <div class="flex">
      <label class="muted">Output format</label>
      <select id="outFormat">
        <option value="lines">One-per-line (plain)</option>
        <option value="indexed">Indexed (1\tpassword)</option>
        <option value="csv">CSV (index,password)</option>
        <option value="json">JSON array</option>
      </select>
    </div>

    <div class="flex">
      <button id="saveConfig" title="Save current settings to this browser">Save configuration</button>
      <button id="clearConfig" class="small-btn" title="Remove saved settings from this browser" style="background:#a61e1e">Clear saved</button>
      <span id="configStatus" class="muted" style="margin-left:6px"></span>
    </div>
  </div>

  <label style="margin-top:12px">Generated Passwords</label>
  <textarea id="output" readonly placeholder="Generated passwords will appear here"></textarea>

  <div id="tableWrapper" style="margin-top:10px"></div>

<script src="words_en_100k.js"></script>
<script src="words_en_5k.js"></script>
<script>
(() => {
  // --- default small wordlist (fallback) ---
  const defaultWords = ["alpha","bravo","charlie","delta","echo","foxtrot","golf","hotel","india","juliet","kilo","lima","mike","november","oscar","papa","quebec","romeo","sierra","tango","uniform","victor","whiskey","xray","yankee","zulu","amber","river","orbit","lumen","pixel","matrix","forge","flux","apex","ember","glint","halo","ion","jet","knoll","mica"];

  // --- element refs ---
  const el = id => document.getElementById(id);
  const folderPicker = el('folderPicker');
  const folderNote = el('folderNote');
  const useLoadedPoolBtn = el('useLoadedPool');
  const clearCacheBtn = el('clearCachedPool');
  const wordsArea = el('wordlist'), outArea = el('output');
  const generateBtn = el('generate'), copyAllBtn = el('copyAll'), copyFmtBtn = el('copyFormatted');
  const outFormat = el('outFormat'), tableWrap = el('tableWrapper');

  // Config persistence elements
  const saveConfigBtn = el('saveConfig');
  const clearConfigBtn2 = el('clearConfig');
  const configStatus = el('configStatus');

  // --- configuration persistence (localStorage) ---
  const CONFIG_KEY = 'kg_user_config_v1';
  const CONFIG_IDB_KEY = 'userConfig';

  function storageAvailable(){
    try {
      const x = '__kg_test__';
      localStorage.setItem(x, x);
      localStorage.removeItem(x);
      return true;
    } catch(e){
      console.warn('localStorage unavailable', e);
      return false;
    }
  }

  function readConfigFromUI(){
    return {
      wordsPer: Math.max(1, parseInt(el('wordsPer').value || 3, 10)),
      charsPerWord: Math.max(0, parseInt(el('charsPerWord').value || 0, 10)),
      digitsPer: Math.max(0, parseInt(el('digitsPer').value || 0, 10)),
      count: Math.max(1, parseInt(el('count').value || 50, 10)),
      sep: el('sep').value,
      capitalizeFirst: el('capitalizeFirst').checked,
      uniqueWords: el('uniqueWords').checked,
      digitPlacement: el('digitPlacement').value,
      outFormat: outFormat.value,
      wordlist: wordsArea.value
    };
  }

  function applyConfigToUI(cfg){
    try {
      if (cfg.wordsPer != null) el('wordsPer').value = cfg.wordsPer;
      if (cfg.charsPerWord != null) el('charsPerWord').value = cfg.charsPerWord;
      if (cfg.digitsPer != null) el('digitsPer').value = cfg.digitsPer;
      if (cfg.count != null) el('count').value = cfg.count;
      if (cfg.sep != null) el('sep').value = cfg.sep;
      if (cfg.capitalizeFirst != null) el('capitalizeFirst').checked = !!cfg.capitalizeFirst;
      if (cfg.uniqueWords != null) el('uniqueWords').checked = !!cfg.uniqueWords;
      if (cfg.digitPlacement != null) el('digitPlacement').value = cfg.digitPlacement;
      if (cfg.outFormat != null) outFormat.value = cfg.outFormat;
      if (typeof cfg.wordlist === 'string') wordsArea.value = cfg.wordlist;
    } catch(err){ console.warn('applyConfigToUI failed', err); }
  }

  function setConfigStatus(msg){
    if (!configStatus) return;
    configStatus.textContent = msg || '';
    if (msg) setTimeout(() => { if (configStatus.textContent === msg) configStatus.textContent = ''; }, 2500);
  }

  async function saveUserConfig(){
    try {
      const cfg = readConfigFromUI();
      const payload = JSON.stringify({ ...cfg, ts: Date.now() });
      let saved = false;
      // Try localStorage (best-effort)
      if (storageAvailable()) {
        try { localStorage.setItem(CONFIG_KEY, payload); saved = true; } catch(e){ console.warn('localStorage save failed', e); }
      }
      // Also try IndexedDB (redundancy)
      try { await idbSet(CONFIG_IDB_KEY, JSON.parse(payload)); saved = true; } catch(e){ console.warn('IndexedDB save failed', e); }
      if (saved) { setConfigStatus('Configuration saved'); return true; }
      alert('Failed to save configuration in this browser.');
      return false;
    } catch(e){
      console.warn('Saving config failed', e);
      alert('Failed to save configuration in this browser.');
      return false;
    }
  }

  async function loadUserConfig(){
    try {
      // Try localStorage first
      if (storageAvailable()) {
        try {
          const raw = localStorage.getItem(CONFIG_KEY);
          if (raw) {
            const cfg = JSON.parse(raw);
            if (cfg && typeof cfg === 'object') {
              applyConfigToUI(cfg);
              setConfigStatus('Loaded saved configuration');
              return true;
            }
          }
        } catch(e){ console.warn('localStorage load failed', e); }
      }
      // Fallback to IndexedDB
      try {
        const cfg = await idbGet(CONFIG_IDB_KEY);
        if (cfg && typeof cfg === 'object') {
          applyConfigToUI(cfg);
          setConfigStatus('Loaded saved configuration');
          return true;
        }
      } catch(e){ console.warn('IndexedDB load failed', e); }
      return false;
    } catch(e){
      console.warn('Loading config failed', e);
      return false;
    }
  }

  async function clearUserConfig(){
    try {
      // Try to remove in both storages
      if (storageAvailable()) {
        try { localStorage.removeItem(CONFIG_KEY); } catch(e){ console.warn('localStorage clear failed', e); }
      }
      try { await idbRemove(CONFIG_IDB_KEY); } catch(e){ console.warn('IndexedDB clear failed', e); }
      setConfigStatus('Saved configuration cleared');
      return true;
    } catch(e){ console.warn('Clearing config failed', e); return false; }
  }

  // --- crypto RNG helpers ---
  function randInt(max){
    if (max <= 0) return 0;
    const arr = new Uint32Array(1);
    window.crypto.getRandomValues(arr);
    return arr[0] % max;
  }
  function randomDigitString(len){
    let s = '';
    for (let i=0;i<len;i++) s += String.fromCharCode(48 + randInt(10));
    return s;
  }
  function shuffleArray(arr){
    for (let i = arr.length - 1; i > 0; i--) {
      const j = randInt(i + 1);
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  // --- IndexedDB small wrapper (promisified) ---
  // Stores object under key 'wordPool' in DB 'pwgen-db' store 'kv'
  function openDB(){
    return new Promise((res, rej)=>{
      const r = indexedDB.open('pwgen-db', 1);
      r.onupgradeneeded = (e) => {
        const db = e.target.result;
        if (!db.objectStoreNames.contains('kv')) db.createObjectStore('kv');
      };
      r.onsuccess = () => res(r.result);
      r.onerror = () => rej(r.error);
    });
  }
  async function idbSet(key, value){
    try {
      const db = await openDB();
      return new Promise((res, rej)=>{
        const tx = db.transaction('kv','readwrite');
        const store = tx.objectStore('kv');
        const req = store.put(value, key);
        req.onsuccess = ()=>{ res(true); db.close(); };
        req.onerror = ()=>{ rej(req.error); db.close(); };
      });
    } catch(e){ console.warn('idbSet failed', e); throw e; }
  }
  async function idbGet(key){
    try {
      const db = await openDB();
      return new Promise((res, rej)=>{
        const tx = db.transaction('kv','readonly');
        const store = tx.objectStore('kv');
        const req = store.get(key);
        req.onsuccess = ()=>{ res(req.result); db.close(); };
        req.onerror = ()=>{ rej(req.error); db.close(); };
      });
    } catch(e){ console.warn('idbGet failed', e); return null; }
  }
  async function idbRemove(key){
    try {
      const db = await openDB();
      return new Promise((res, rej)=>{
        const tx = db.transaction('kv','readwrite');
        const store = tx.objectStore('kv');
        const req = store.delete(key);
        req.onsuccess = ()=>{ res(true); db.close(); };
        req.onerror = ()=>{ rej(req.error); db.close(); };
      });
    } catch(e){ console.warn('idbRemove failed', e); }
  }

  // --- folder loader & parser ---
  // sanitize a candidate word: lowercase, remove odd chars (keep letters, numbers, dash, apostrophe)
  function sanitizeWord(s){
    // Keep letters only for real-word filtering
    return s.trim().toLowerCase().replace(/[^a-z]/g,'');
  }

  async function wordsFromFile(file){
    const text = await file.text();
    // split on newlines and common separators, filter, sanitize
    const raw = text.split(/\r?\n|,|\r/).map(s=>s.trim()).filter(Boolean);
    return raw.map(s=>sanitizeWord(s)).filter(Boolean);
  }

  async function loadPoolFromFolder(filesList){
    const arr = Array.from(filesList).filter(f=>/\.txt$/i.test(f.name));
    if (arr.length === 0) throw new Error('No .txt files found in selected folder.');
    let words = [];
    // read sequentially to avoid spiking memory on low-end machines
    for (let i=0;i<arr.length;i++){
      try {
        const w = await wordsFromFile(arr[i]);
        words = words.concat(w);
      } catch(e){ console.warn('Failed reading', arr[i].name, e); }
    }
    // dedupe
    const set = new Set(words.filter(Boolean));
    const pool = Array.from(set);
    return pool;
  }

  // --- insert digits helpers (same as earlier) ---
  function insertDigitsIntoWord(word, digits) {
    if (!digits) return word;
    const pos = randInt(word.length + 1);
    return word.slice(0,pos) + digits + word.slice(pos);
  }

  function pickWords(pool, wordsPer, unique){
    if (unique && pool.length >= wordsPer) {
      const copy = pool.slice();
      shuffleArray(copy);
      return copy.slice(0, wordsPer);
    }
    const res = [];
    for (let i=0;i<wordsPer;i++) res.push(pool[randInt(pool.length)]);
    return res;
  }

  function generateOne(pool, wordsPer, digitsPer, sep, capFirst, placement, unique){
    const chosen = pickWords(pool, wordsPer, unique);
    if (capFirst) chosen[0] = chosen[0].charAt(0).toUpperCase() + chosen[0].slice(1);
    const wordsCopy = chosen.slice();
    if (digitsPer <= 0) return wordsCopy.join(sep);

    if (placement === 'end') return wordsCopy.join(sep) + randomDigitString(digitsPer);
    if (placement === 'start') return randomDigitString(digitsPer) + wordsCopy.join(sep);

    if (placement === 'after_each') {
      const base = Math.floor(digitsPer / wordsPer);
      let remainder = digitsPer - base * wordsPer;
      const parts = wordsCopy.map(w => {
        const take = base + (remainder > 0 ? 1 : 0);
        if (remainder > 0) remainder--;
        return w + (take > 0 ? randomDigitString(take) : '');
      });
      return parts.join(sep);
    }

    if (placement === 'per_word_random') {
      const counts = new Array(wordsPer).fill(0);
      for (let d=0; d<digitsPer; d++) counts[randInt(wordsPer)]++;
      const parts = wordsCopy.map((w, idx) => {
        const digits = counts[idx] > 0 ? randomDigitString(counts[idx]) : '';
        return insertDigitsIntoWord(w, digits);
      });
      return parts.join(sep);
    }

    if (placement === 'inside_each_word') {
      const parts = wordsCopy.slice();
      const counts = new Array(wordsPer).fill(0);
      if (digitsPer >= wordsPer) {
        for (let i=0;i<wordsPer;i++) counts[i] = 1;
        let remaining = digitsPer - wordsPer;
        for (let r=0;r<remaining;r++) counts[randInt(wordsPer)]++;
      } else {
        let picks = 0;
        while (picks < digitsPer) {
          const idx = randInt(wordsPer);
          if (counts[idx] === 0) { counts[idx] = 1; picks++; }
        }
      }
      for (let i=0;i<wordsPer;i++){
        if (counts[i] > 0) parts[i] = insertDigitsIntoWord(parts[i], randomDigitString(counts[i]));
      }
      return parts.join(sep);
    }

    return wordsCopy.join(sep) + randomDigitString(digitsPer);
  }

  function formatOutput(list, format){
    if (format === 'lines') return list.join('\n');
    if (format === 'indexed') return list.map((p,i)=>`${i+1}\t${p}`).join('\n');
    if (format === 'csv') return 'index,password\n' + list.map((p,i)=>`${i+1},"${p.replace(/"/g,'""')}"`).join('\n');
    if (format === 'json') return JSON.stringify(list, null, 2);
    return list.join('\n');
  }

  function renderTable(list){
    if (!list || list.length === 0){ tableWrap.innerHTML = ''; return; }
    const rows = list.map((p,i)=>`<tr><td style="width:46px">${i+1}</td><td style="font-family:monospace">${p}</td><td style="width:110px"><button class="small-btn" data-i="${i}">Copy</button></td></tr>`).join('');
    tableWrap.innerHTML = `<table><thead><tr><th>#</th><th>Password</th><th>Copy</th></tr></thead><tbody>${rows}</tbody></table>`;
    tableWrap.querySelectorAll('button.small-btn').forEach(btn=>{
      btn.addEventListener('click', async ()=>{
        const idx = parseInt(btn.getAttribute('data-i'),10);
        await navigator.clipboard.writeText(list[idx]);
        btn.textContent = 'Copied ✓';
        setTimeout(()=> btn.textContent = 'Copy', 900);
      });
    });
  }

  // --- runtime state & helpers ---
  window.loadedExternalPool = null; // set when folder loaded or rehydrated
  const IDB_KEY = 'wordPool';

  // try to load any previously saved user configuration
  loadUserConfig();

  // Hook up config buttons
  if (saveConfigBtn) {
    saveConfigBtn.addEventListener('click', () => {
      saveUserConfig();
    });
  }
  if (clearConfigBtn2) {
    clearConfigBtn2.addEventListener('click', () => {
      if (confirm('Remove saved configuration from this browser?')) {
        clearUserConfig();
      }
    });
  }

  // Auto-save on change (debounced)
  function debounce(fn, ms){
    let t; return (...args) => { clearTimeout(t); t = setTimeout(()=>fn(...args), ms); };
  }
  const debouncedSave = debounce(()=>{ saveUserConfig(); }, 400);
  ['wordsPer','charsPerWord','digitsPer','count','sep','capitalizeFirst','uniqueWords','digitPlacement','outFormat','wordlist']
    .forEach(id => {
      const n = el(id);
      if (!n) return;
      const ev = (n.tagName === 'TEXTAREA' || n.tagName === 'INPUT') ? 'input' : 'change';
      n.addEventListener(ev, debouncedSave);
    });

  // try to rehydrate cached pool from IndexedDB at startup
  (async function tryRehydrate(){
    try {
      const cached = await idbGet(IDB_KEY);
      if (cached && Array.isArray(cached.pool) && cached.pool.length){
        window.loadedExternalPool = cached.pool;
        folderNote.textContent = `Rehydrated cached pool — ${cached.pool.length} words.`;
        useLoadedPoolBtn.disabled = false;
      } else {
        folderNote.textContent = 'No folder loaded. Using built-in pool or textarea input.';
      }
    } catch(e){
      folderNote.textContent = 'IndexedDB unavailable; using built-in or textarea.';
      console.warn(e);
    }
  })();

  // folder selection handler
  folderPicker.addEventListener('change', async (ev)=>{
    try {
      const files = ev.target.files;
      if (!files || files.length === 0) { folderNote.textContent = 'No files selected.'; return; }
      folderNote.textContent = 'Loading and parsing .txt files — please wait...';
      const pool = await loadPoolFromFolder(files);
      // basic size check and warn if huge
      if (pool.length > 200000) {
        folderNote.textContent = `Imported ${pool.length} words (truncated to 200k for safety).`;
      } else {
        folderNote.textContent = `Loaded ${pool.length} unique words from folder — caching locally...`;
      }
      // attempt to cache (may fail if quota exceeded)
      try {
        await idbSet(IDB_KEY, {ts:Date.now(), pool});
        folderNote.textContent = `Loaded & cached ${pool.length} words locally. Ready.`;
        window.loadedExternalPool = pool;
        useLoadedPoolBtn.disabled = false;
      } catch(e){
        folderNote.textContent = `Loaded ${pool.length} words (cache failed: ${e && e.message ? e.message : 'unknown'}). Using in-memory only.`;
        window.loadedExternalPool = pool;
        useLoadedPoolBtn.disabled = false;
      }
    } catch(err){
      console.error(err);
      folderNote.textContent = 'Failed to load folder: ensure folder has .txt files and try again.';
    }
  });

  // use loaded pool button (explicit)
  useLoadedPoolBtn.addEventListener('click', ()=>{
    if (window.loadedExternalPool && window.loadedExternalPool.length){
      folderNote.textContent = `Using loaded pool — ${window.loadedExternalPool.length} words.`;
    } else {
      folderNote.textContent = 'No loaded pool found.';
    }
  });

  clearCacheBtn.addEventListener('click', async ()=>{
    try {
      await idbRemove(IDB_KEY);
      window.loadedExternalPool = null;
      folderNote.textContent = 'Cleared cached pool. Using built-in or textarea.';
      useLoadedPoolBtn.disabled = true;
      alert('Cached word pool cleared.');
    } catch(e){
      console.warn(e);
      alert('Failed to clear cache.');
    }
  });

  // --- main generation handler ---
  generateBtn.addEventListener('click', ()=>{
    // source selection: textarea > loadedExternalPool > built-in
    const wordsText = wordsArea.value.trim();
    let pool = (wordsText ? wordsText.split(/\r?\n/).map(s=>sanitizeWord(s)).filter(Boolean) : null);
    if (!pool || pool.length === 0) {
      if (window.loadedExternalPool && window.loadedExternalPool.length) {
        pool = window.loadedExternalPool.slice();
      } else if (Array.isArray(window.WORDS_EN_100K) && window.WORDS_EN_100K.length) {
        pool = window.WORDS_EN_100K.slice();
      } else if (Array.isArray(window.WORDS_EN_5K) && window.WORDS_EN_5K.length) {
        pool = window.WORDS_EN_5K.slice();
      } else {
        pool = defaultWords.slice();
      }
    }

    // optional: restrict words to a specific character length
    const charsPer = Math.max(0, parseInt(el('charsPerWord').value || 0, 10));
    if (charsPer > 0) {
      const filtered = pool.filter(w => typeof w === 'string' && w.length === charsPer);
      if (filtered.length === 0) {
        alert(`No words of length ${charsPer} found in the current pool. Add words, load a folder, or change the length.`);
        return;
      }
      pool = filtered;
    }

    const wordsPer = Math.max(1, parseInt(el('wordsPer').value || 3,10));
    const digitsPer = Math.max(0, parseInt(el('digitsPer').value || 0,10));
    const count = Math.max(1, Math.min(5000, parseInt(el('count').value || 50,10)));
    const sep = el('sep').value;
    const capFirst = el('capitalizeFirst').checked;
    const uniqueWords = el('uniqueWords').checked;
    let placement = el('digitPlacement').value;

    // Preserve word length: when exact chars per word is set, avoid inserting digits inside words
    if (charsPer > 0 && (placement === 'per_word_random' || placement === 'inside_each_word')) {
      placement = 'after_each';
    }

    if (pool.length === 0) { alert('Word pool is empty. Provide words or load a folder.'); return; }
    if (wordsPer > pool.length && uniqueWords) {
      if (!confirm('You asked for unique words per password but the pool is smaller than wordsPer; duplicates may be used. Continue?')) return;
    }
    if (count > 2000) {
      if (!confirm('Generating a large number of passwords ('+count+'). Continue?')) return;
    }

    const out = [];
    for (let i=0;i<count;i++){
      out.push(generateOne(pool, wordsPer, digitsPer, sep, capFirst, placement, uniqueWords));
    }

    const fmt = outFormat.value;
    outArea.value = formatOutput(out, fmt);
    outArea.select();
    copyAllBtn.disabled = false;
    copyFmtBtn.disabled = false;
    renderTable(out);
    copyAllBtn.dataset.raw = JSON.stringify(out);
    copyFmtBtn.dataset.raw = JSON.stringify({list: out, fmt: fmt});
  });

  copyAllBtn.addEventListener('click', async ()=>{
    const raw = copyAllBtn.dataset.raw;
    if (!raw) return;
    const list = JSON.parse(raw);
    await navigator.clipboard.writeText(list.join('\n'));
    copyAllBtn.textContent = 'Copied ✓';
    setTimeout(()=> copyAllBtn.textContent = 'Copy All (plain lines)', 900);
  });

  copyFmtBtn.addEventListener('click', async ()=>{
    const raw = copyFmtBtn.dataset.raw;
    if (!raw) return;
    const obj = JSON.parse(raw);
    const txt = formatOutput(obj.list, obj.fmt);
    await navigator.clipboard.writeText(txt);
    copyFmtBtn.textContent = 'Copied ✓';
    setTimeout(()=> copyFmtBtn.textContent = 'Copy (Formatted)', 900);
  });

})();
</script>
</body>
</html>